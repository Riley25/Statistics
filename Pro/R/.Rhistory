return(ARRAY_I)
}
#EXAMPLE HERE
BINOMIAL()
#
# NAME: BINOMIAL.R
#
# PURPOSE: Generate a plot, and return an array of values,
#          for a binomial experiment.
#
# AUTHOR: R.N.H.
#
# SPECIAL NOTES:
#
#   PLOTTING 'TYPES':
#      "p" for points,
#      "l" for lines,
#      "b" for both,
#      "c" for the lines part alone of "b",
#      "o" for both 'overplotted',
#      "h" for 'histogram' like (or 'high-density') vertical lines,
#      "s" for stair steps,
#      "S" for other steps, see 'Details' below,
#      "n" for no plotting.
#
factorial_function = function(num){
#PURPOSE: This function takes the n factorial for any integer > 0  (n!)
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
#EXAMPLE:
number = factorial_function(3)
number
BINOMIAL = function(){
p <- as.numeric(readline(prompt = paste("What is the probability of success (p)?",":")))
n <- as.numeric(readline(prompt = paste("How many trials (n)?",":")))
factorial_function = function(num){
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
q=1-p
x=seq(0,n,1)
ARRAY_I = matrix(c(rep(NA,length(x))),nrow = 1)
for(i in 1:length(x)){
ARRAY_I[i] = ((factorial_function(n))/(factorial_function(x[i]) * factorial_function(n-x[i]))) * p^x[i] * (1-p)^(n-x[i])
}
colnames(ARRAY_I) = as.character(c(seq(0,length(x)-1,1)))
rownames(ARRAY_I) = 'p(x)  '
plot(seq(0,length(x)-1,1),ARRAY_I, type = 'b',xlab = 'Trial Number', ylab = 'p(x)',main = 'Binomial Distribution')
return(ARRAY_I)
}
#EXAMPLE HERE
BINOMIAL()
#
# NAME: BINOMIAL.R
#
# PURPOSE: Generate a plot, and return an array of values,
#          for a binomial experiment.
#
# AUTHOR: R.N.H.
#
# SPECIAL NOTES:
#
#   PLOTTING 'TYPES':
#      "p" for points,
#      "l" for lines,
#      "b" for both,
#      "c" for the lines part alone of "b",
#      "o" for both 'overplotted',
#      "h" for 'histogram' like (or 'high-density') vertical lines,
#      "s" for stair steps,
#      "S" for other steps, see 'Details' below,
#      "n" for no plotting.
#
factorial_function = function(num){
#PURPOSE: This function takes the n factorial for any integer > 0  (n!)
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
#EXAMPLE:
number = factorial_function(3)
number
BINOMIAL = function(){
p <- as.numeric(readline(prompt = paste("What is the probability of success (p)?",":")))
n <- as.numeric(readline(prompt = paste("How many trials (n)?",":")))
factorial_function = function(num){
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
q=1-p
x=seq(0,n,1)
ARRAY_I = matrix(c(rep(NA,length(x))),nrow = 1)
for(i in 1:length(x)){
ARRAY_I[i] = ((factorial_function(n))/(factorial_function(x[i]) * factorial_function(n-x[i]))) * p^x[i] * (1-p)^(n-x[i])
}
colnames(ARRAY_I) = as.character(c(seq(0,length(x)-1,1)))
rownames(ARRAY_I) = 'p(x)  '
plot(seq(0,length(x)-1,1),ARRAY_I, type = 'b',xlab = 'Trial Number', ylab = 'p(x)',main = 'Binomial Distribution')
return(ARRAY_I)
}
#EXAMPLE HERE
BINOMIAL()
1-.4632
factorial_function = function(num){
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
NEGATIVE_BINOMIAL = function(){
p <- as.numeric(readline(prompt = paste("What is the probability of success (p)?",":")))
n <- as.numeric(readline(prompt = paste("How many trials (n)?",":")))
r <- as.numeric(readline(prompt = paste("How many success (r)?",":")))
factorial_function = function(num){
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
q=1-p
x=seq(0,n,1)
ARRAY_1 = matrix(c(rep(NA,length(x))),nrow = 1)
for(i in 1:length(x)){
#ARRAY_I[i] = ((factorial_function(n))/(factorial_function(x[i]) * factorial_function(n-x[i]))) * p^x[i] * (1-p)^(n-x[i])
ARRAY_1[i] = ((factorial_function(r+x[i]-1))/(factorial_function(r-1) * factorial_function(r+x[i]-1-r+1))) *p^r * (1-p)^x[i]
}
colnames(ARRAY_1) = as.character(c(seq(0,length(x)-1,1)))
rownames(ARRAY_1) = 'p(x)  '
plot(seq(0,length(x)-1,1),ARRAY_1, type = 'l',xlab = 'Trial Number', ylab = 'p(x)',main = 'Negative Binomial Distribution')
return(ARRAY_1)
}
NEGATIVE_BINOMIAL()
NEGATIVE_BINOMIAL = function(){
p <- as.numeric(readline(prompt = paste("What is the probability of success (p)?",":")))
n <- as.numeric(readline(prompt = paste("How many trials (n)?",":")))
factorial_function = function(num){
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
r = seq(1,6,1) #this is how many different values we wish to have.
q=1-p
x=seq(0,n,1)
ARRAY_1 = matrix(c(rep(NA,length(x)*length(r))),ncol = length(x),nrow =length(r), byrow = TRUE)
#ARRAY_1 = NULL
for(j in 1:length(r)){
for(i in 1:length(x)){
ARRAY_1[j,i] = ((factorial_function(r[j]+x[i]-1))/(factorial_function(r[j]-1) * factorial_function(r[j]+x[i]-1-r[j]+1))) *p^r[j] * (1-p)^x[i]
}}
colnames(ARRAY_1) = as.character(c(seq(0,length(x)-1,1)))
rownames(ARRAY_1) = c(rep('p(x)  ',length(r)))
color_table = c(1,2,3,4,6,5)
plot(seq(0,length(x)-1,1),ARRAY_1[1,], type = 'b',xlab = 'Trial Number', ylab = 'p(x)',main = 'Negative Binomial Distribution',ylim = c(min(ARRAY_1),max(ARRAY_1)))
for(i in 2:length(r)){
lines(seq(0,length(x)-1,1),ARRAY_1[i,],col = color_table[i], type = 'b',xlab = 'Trial Number', ylab = 'p(x)',main = 'Negative Binomial Distribution')
}
return(ARRAY_1)
}
NEGATIVE_BINOMIAL()
factorial_function = function(num){
#PURPOSE: This function takes the n factorial for any integer > 0  (n!)
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
#EXAMPLE:
number = factorial_function(3)
number
BINOMIAL = function(){
p <- as.numeric(readline(prompt = paste("What is the probability of success (p)?",":")))
n <- as.numeric(readline(prompt = paste("How many trials (n)?",":")))
factorial_function = function(num){
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
q=1-p
x=seq(0,n,1)
ARRAY_I = matrix(c(rep(NA,length(x))),nrow = 1)
for(i in 1:length(x)){
ARRAY_I[i] = ((factorial_function(n))/(factorial_function(x[i]) * factorial_function(n-x[i]))) * p^x[i] * (1-p)^(n-x[i])
}
colnames(ARRAY_I) = as.character(c(seq(0,length(x)-1,1)))
rownames(ARRAY_I) = 'p(x)  '
plot(seq(0,length(x)-1,1),ARRAY_I, type = 'b',xlab = 'Trial Number', ylab = 'p(x)',main = 'Binomial Distribution')
return(ARRAY_I)
}
#EXAMPLE HERE
BINOMIAL()
factorial_function = function(num){
#PURPOSE: This function takes the n factorial for any integer > 0  (n!)
fact = NULL
if(num <= 1){fact = 1}
else{for(i in 0:num-1) {
fact[i] = (num -i)}
fact = prod(fact)  * num}
}
N_X = function(n,x){
#purpose: This is the combination function which is without replacement and without regard to order.
#          formula below.
# (n) = n!
# (x)   x!(n-x)!
diff = n - x
numerator = factorial_function(n)
denominator = factorial_function(x) * factorial_function(diff)
answer = numerator / denominator
return(answer)
}
N_X(3,2)
Hyper_func = function(type_1_object,type_2_object,n){
#purpose: This is the hypergeometric function.
#          formula below.
#
#   K = Type I object drawn
# M-K = Type II object drawn
#   M = Type I + Type II (total number of in survery)
K = type_1_object
M = K + type_2_object
M_K = type_2_object
x=seq(0,n,1)
ARRAY_I = matrix(c(rep(NA,length(x)+1)),nrow = 1)
for(i in 0:length(x)){
numerator = N_X(K,i) * N_X(M_K,n-i)
denominator = N_X(M,n)
ARRAY_I[1,i+1] = (numerator/denominator)
}
colnames(ARRAY_I) = as.character(c(seq(0,length(x),1)))
rownames(ARRAY_I) = 'p(x)  '
plot(seq(0,length(x),1),ARRAY_I, type = 'b',xlab = 'X = Type I object', ylab = 'p(x)',main = 'Hypergeometric Distribution')
#sentance = print(paste(c("The probability of x = ",min(x)," is  ",round(ARRAY_I[1,1]),ndigits=5),collapse = ''))
E = n*K/M; E = round(E,digits = 2)
var = (n*K*(M_K)*(M-n))/(M^2*(M-1)) ; var = round(var,digits = 2)
statement1 = print(paste(c("The expected value is... ",E),collapse = ''))
statement2 = print(paste(c("The variance is... ",var),collapse = ''))
#print(statement1)
#print(statement2)
return(ARRAY_I)
}
Hyper_func(42,12,52)
Hyper_func(12,12,52)
NEGATIVE_BINOMIAL()
#EXAMPLE HERE
BINOMIAL()
#EXAMPLE HERE
BINOMIAL()
#EXAMPLE HERE
BINOMIAL()
#EXAMPLE HERE
BINOMIAL()
NEGATIVE_BINOMIAL()
..1666
#EXAMPLE HERE
BINOMIAL()
1/6
NEGATIVE_BINOMIAL()
NEGATIVE_BINOMIAL()
NEGATIVE_BINOMIAL()
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
#  prettydoc::html_pretty:
#    theme: cayman
#    highlight: github
require(HH)
setwd("D:/Documents/R/705/project")
credit = read.csv(file = "loans50k.csv")
gf_bar(~status,fill=~grade,position=position_dodge(),data=credit) + xlab(c("Bad = 0                                                         Good = 1"))
gf_bar(~status,fill=~grade,position=position_dodge(),data=credit) + xlab(c("Bad = 0                                                         Good = 1"))
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
#  prettydoc::html_pretty:
#    theme: cayman
#    highlight: github
require(HH)
setwd("D:/Documents/R/705/project")
credit = read.csv(file = "loans50k.csv")
library(ggformula)
library(ggplot2)
library(dplyr)
library(moments)
library(xlsx)
library(plotly)
library(ROCR)
#The code below will remove any NA's from our data frame.
credit = na.omit(credit)
credit =
credit %>%
mutate(status = case_when(
status == "Charged Off" |status == "Default" ~1,
status == "Fully Paid"~ 0,
status == "Current" | status == "In Grace Period"| status == "Late (16-30 days)" | status == "Late (31-120 days)" ~ 2
#TRUE ~ "Something is wrong"
))
credit[, 'status'] <- as.factor(credit[, 'status'])
summary(credit$status)
#This table in important because it show how many are "Good" "Bad" and how many should be removed.
# This will remove all oberservations that have the "Remove" label for the status variable.
#credit$status = credit$status[!is.na(credit$status)]
toBeRemoved<-which(credit$status==2)
credit<-credit[-toBeRemoved,]
credit$status = factor(credit$status)
summary(credit$status)
summary(credit$reason)
credit =
credit%>%
mutate(reason = case_when(
reason == "house" | reason=="car" | reason =="home_improvement" | reason == "major_purchase" | reason == "medical" | reason == "moving" | reason == "other" | reason == "renewable_energy" | reason == "small_business" | reason == "vacation" | reason == "wedding" ~ "other",
reason == "credit_card"~"credit_card",
reason == "debt_consolidation"~"debt_consolidation"
))
credit[, 'reason'] <- as.factor(credit[, 'reason'])
# This will combine our variables into 3 categories.
a = 50000-dim(credit)[1]
print(paste(c("Total number of observations removed is   ",a),collapse = ''))
#View(sub_credit)
credit_avg =
credit%>%
group_by(status)%>%
summarise(meanAmount=mean(amount))
#gf_col(meanAmount~status,data = credit_avg)
print(credit_avg)
bad = credit$amount[credit$status==1]
good = credit$amount[credit$status==0]
mean(bad)
mean(good)
t.test(bad,good,alternative = "greater")
credit%>%
gf_histogram(~amount,data=credit,fill=~status,position = PositionDodge)
summary(credit$status)
gf_bar(~status,fill=~grade,position=position_dodge(),data=credit) + xlab(c("Bad = 0                                                         Good = 1"))
gf_bar(~status,fill=~grade,position=position_dodge(),data=credit) + xlab(c("Good = 0                                                         Bad = 1"))
c = .80
random_subset = select_rand_int(10,c)
random_subset
for (i in 1:for_max) {
new_number = round(runif(1,min=0,max = length(df)),digits = 0)
df = df[-new_number]
test_data[i] = new_number
}
select_rand_int = function(n,c){
# PURPOSE: Function was intended for model generation.
#         This function will select random intergers 1 through n.
#         Where n = number of rows in our data frame.
#
#         c = constant. (i.e. what % of the data should be selected?)
#         0 < c < 1
for_max = round((1-c)*n,digits = 0)
df = seq(1,n,1)
test_data = NULL
for (i in 1:for_max) {
new_number = round(runif(1,min=0,max = length(df)),digits = 0)
df = df[-new_number]
test_data[i] = new_number
}
print(paste(c("Total Number of Observations Removed = ",for_max),collapse = ''))
return(df)
}
nrow = dim(credit)[1]
c = .80
random_subset = select_rand_int(10,c)
random_subset
for_max = round((1-c)*n,digits = 0)
select_rand_int = function(n,c){
# PURPOSE: Function was intended for model generation.
#         This function will select random intergers 1 through n.
#         Where n = number of rows in our data frame.
#
#         c = constant. (i.e. what % of the data should be selected?)
#         0 < c < 1
for_max = round((1-c)*n,digits = 0)
df = seq(1,n,1)
test_data = NULL
for (i in 1:for_max) {
new_number = round(runif(1,min=0,max = length(df)),digits = 0)
df = df[-new_number]
test_data[i] = new_number
}
print(paste(c("Total Number of Observations Removed = ",for_max),collapse = ''))
return(df)
}
nrow = dim(credit)[1]
c = .80
random_subset = select_rand_int(nrow,c)
#random_subset
train_credit = credit[random_subset,]
test_credit  = credit[-random_subset,]
test_credit$status = as.factor(test_credit$status)
train_credit$status = as.factor(train_credit$status)
glm_test1 = glm(status~
amount
+term
+rate
+grade
+verified
+reason
+debtIncRat
+delinq2yr
+inq6mth
+totalRevLim
+accOpen24
+totalLim
+totalRevBal
+totalIlLim,
family = "binomial",data = train_credit)
nrow = dim(credit)[1]
c = .80
random_subset = select_rand_int(nrow,c)
#random_subset
train_credit = credit[random_subset,]
test_credit  = credit[-random_subset,]
test_credit$status = as.factor(test_credit$status)
train_credit$status = as.factor(train_credit$status)
glm_test1 = glm(status~
amount
+term
+rate
+grade
+verified
+reason
+debtIncRat
+delinq2yr
+inq6mth
+totalRevLim
+accOpen24
+totalLim
+totalRevBal
+totalIlLim,
family = "binomial",data = train_credit)
#summary output here.
summary(glm_test1)
threshold = .50
# Plese note, we are using our test data for prediction.
pred = predict(glm_test1,newdata = test_credit,type = "response")
# IF our prediciton result is greater then threshold,
# THEN set value = 1
# ELSE set value = 0
pred = ifelse(pred > threshold,1,0)
###################################
# THIS IS WHAT ACTUALLY HAPPEND.
test_check = test_credit$status
Error <- mean(pred != test_check)
print(paste(c("The error rate is..  ",round(Error*100,digits = 2)," %"),collapse = ''))
seq = seq(0,1,.01)
error_array = NULL
j=1
for (i in seq) {
pred = predict(glm_test1,newdata = test_credit,type = "response")
pred = ifelse(pred > i,1,0)
test_check = test_credit$status
Error <- mean(pred != test_check)
error_array[j] = Error
j=j+1
}
data = as.data.frame(matrix(c(seq,error_array),ncol = 2))
colnames(data) = c("Threshold","Error")
ggplot(data = data,aes(x=Threshold, y=Error)) +
geom_line()
pred = ifelse(pred > threshold,1,0)
index<-which(pred==0)
good_cases = test_credit[index,]
TOTAL_REVENUE = sum(good_cases$totalPaid)
###################################
seq = seq(0,1,.01)
error_array = NULL
Rev_array = NULL
j=1
for (i in seq) {
pred = predict(glm_test1,newdata = test_credit,type = "response")
pred = ifelse(pred > i,1,0)
index<-which(pred==0)
good_cases = test_credit[index,]
TOTAL_REVENUE = sum(good_cases$totalPaid) - sum(good_cases$amount)
Rev_array[j] = TOTAL_REVENUE
j=j+1
}
data = as.data.frame(matrix(c(seq,Rev_array),ncol = 2))
colnames(data) = c("Threshold","Profit")
ggplot(data = data,aes(x=Threshold, y=Profit)) +
geom_line()
pred = predict(glm_test1,newdata = test_credit,type = "response")
pr <- prediction(pred, test_credit$status)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf,main = "ROC Curve")
lines(seq(0,1,.05),seq(0,1,.05),type = 'c',lwd=1.5)
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
print(paste(c("The area under the curve is ",round(auc,digits = 3)),collapse = ''))
